---
title: 设计模式
date: 2019-10-22 21:36:28
tags:
	- blog
	- 基础
	
---
# 设计模式
六大原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则

## 单一职责原则 
就一个类而言，应该仅有一个能引起它变化的原因
开发：避免一个类承担过多的职责

## 开放封闭原则
类、模块、函数等对扩展开发，对修改关闭
开发：面对经常变更的功能可以用抽象或接口的方式来设置抽象功能接口，当修改时，只需要增加抽象接口和接口的子类，具体的实现类不改变

## 里氏替换原则
所有引用父类的地方都可以使用其子类对象的引用替换，是实现开放封闭原则的具体手段之一
开发：程序设计时，尽量把父类设置成抽象或接口，让子类继续或实现父接口，在运行时子类实例替换父类实例

## 依赖倒置原则
高层模块不应该依赖低层模块，两者都应该依赖于抽象；抽象不依赖于细节，细节依赖于抽象
开发：模块间的依赖都通过抽象发生，实现类之间不发生直接依赖关系，mvp中view和model间的相互隔离，当之一改变时不影响其他

## 迪米特原则 
一个软件实体应该尽可能少的与其他实现发生相互作用
引入合理的第三者降低现有两个对象之间的耦合度，

## 接口隔离原则
一个类对另一个类的依赖应该建立在最小的接口上（细化接口，区分接口职责）

<!--more-->

# 常用设计模式 3类23种
类型：创建型设计模式、结构型设计模式、行为型设计模式


## 创建型：
创建对象有关，5种
#### 单例设计模式：
懒汉、饿汉、双重检查、内部类、安全懒汉、枚举
#### 建造者模式： 
将构建过程和表示分离，构建不同，表示不同
结构：
	导演类;
	抽象builder;
	具体建造者;
	产品类
	
#### 简单工厂模式（不是设计模式，只是工厂方法模式的简单化） 

#### 工厂方法模式：是类的实例化延迟到其子类 
结构：
	创建抽象工厂、
	具体抽象工厂、
	抽象产品、
	实际产品

## 结构型： 
从程序的结构上解决模块之间的耦合问题

#### 代理模式：静态代理、动态代理  
又称委托模式，为其他对象提供一种代理以控制对这个对象的访问
结构：
	抽象主题类
	真实主题类
	代理类
	-客户端调用
	
	
#### 装饰模式 
动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活
结构：
	抽象组件Component
	组件的具体实现类ConCreteComponent
	抽象装饰者Decorator
	装饰的具体实现类ConCreteDecorator

#### 外观模式
又称门面模式，要求一个子系统的外部与内部的通信必须通过一个统一的对象进行，此模式提供一个高层的接口，使得子系统更易于使用
结构：
	外观类facade
	子系统类Subsystem
	
#### 享元模式
使用共享对象有效地支持大量细粒度的对象，分为内、外部状态，内部状态是共享内容，外部状态是对象依赖的标记，随环境变化，不可共享
结构：
	抽象享元角色Flyweight
	具体享元角色ConcreteFlyweight
	享元工厂FlyweightFactory
	
## 行为型：
处理类或对象如何交互及如何分配职责，有11种

#### 策略模式 
定义一系列算法，把每一个算法封装起来，并且使它们可以相互替换。策略模式使得算法可独立于使用它的客户而变化
结构：
	上下文角色Context
	抽象策略角色Strategy
	具体的策略角色ConcreteStrategy

#### 模板方法模式
定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类不改变一个算法的结构即可重定义算法的某些特定步骤 
结构：
	抽象类
	具体实现类

#### 观察者模式
定义对象间一对多的依赖关系，每当一个对象改变状态时，则所有依赖于它的对象都是得到通知并被自动更新
结构：
	抽象被观察者
	具体被观察者
	抽象观察者
	具体观察者
